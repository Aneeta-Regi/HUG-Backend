class TutorReportController < ApplicationController
  before_action :authenticate_token!
  #before_action :set_school
  before_action :set_users

  def tutor_report
    # remove duplicate users generated by multiple schools.
    @users_uniq = @users.uniq
    # number of primary
    @primary = @users_uniq.select { |u| u[:active] == true && u[:commitment_level] == 'Primary' }
    # number of substitute
    @secondary = @users_uniq.select { |u| u[:active] == true && u[:commitment_level] == 'Substitute' }
    # get the sessions & feedback
    total_sessions = set_total_session
    engagement_average = avg_engagement
    # set the number of tutor hours
    total_tutor_hours = total_sessions * 1.5
    sec_grade_session_hours = @sec_grade_sessions.size * 1.5
    trd_grade_session_hours = @trd_grade_sessions.size * 1.5
    # total users
    total_active = @primary.size + @secondary.size
    # number of inactive
    total_inactive = @users_uniq.size - total_active
    # setup for individual report or group of tutors
    if params[:tutor_id].to_i.zero?
      tutor_report = { total_tutors: @users_uniq.size, total_active: total_active,
                       total_inactive: total_inactive, total_substitute: @secondary.size,
                       total_primary: @primary.size, total_sessions: total_sessions, total_tutor_hours: total_tutor_hours,
                       sec_grade_sessions: @sec_grade_sessions.size, sec_grade_session_hours: sec_grade_session_hours,
                       trd_grade_sessions: @trd_grade_sessions.size, trd_grade_session_hours: trd_grade_session_hours,
                       engagement_average: engagement_average, total_users: @users.size, all_found_sessions: @afs.size}
      render json: tutor_report
    else
      tutor_name = @users_uniq[0].first_name + ' ' + @users_uniq[0].last_name
      @student_lists = []
      @users_uniq[0].school_id.each do |s|
        p 'school id is'
        p s
        school_sessions = @sessions.select { |ss| ss[:school_id] == s }
        p 'school sessions'
        p school_sessions
        unless school_sessions.empty?
          school_name = school_sessions[0].school_name
          students_list = []
          school_sessions.each do |sss|
            p sss.student_name
            students_list << sss.student_name
          end
          students_list = students_list.sort_by!{ |e| e.downcase }
          list_object = {school_name: school_name, students: students_list.uniq}
          @student_lists << list_object
        end

      end

      tutor_report = { tutor_name: tutor_name, total_sessions: total_sessions, total_tutor_hours: total_tutor_hours,
                       sec_grade_sessions: @sec_grade_sessions.size, sec_grade_session_hours: sec_grade_session_hours,
                       trd_grade_sessions: @trd_grade_sessions.size, trd_grade_session_hours: trd_grade_session_hours,
                       engagement_average: engagement_average, student_lists: @student_lists, all_found_sessions: @afs.size}
      render json: tutor_report
    end

  end

  def set_total_session
    @sessions = []
    @afs = []
    @sec_grade_sessions = []
    @trd_grade_sessions = []

    @users_uniq.each do |u|
      # handle the year
      if params[:school_year].to_i.zero?
        # all sessions for all time
        user_sessions = Session.where(vol_id: u.id, second_attempt: true)
      else
        # all sessions for one year
        user_sessions = Session.where(vol_id: u.id, second_attempt: true, school_year: params[:school_year])
      end

      # sort the sessions by user and school
      if params[:school_id].to_i.zero?
        (@sessions << user_sessions).flatten!
      else
        # select the user sessions with the school id
        reduced_sessions = user_sessions.select { |s| s[:school_id] == params[:school_id].to_i}
        p reduced_sessions
        (@sessions << reduced_sessions).flatten!
        p @sessions.size
        # add those sessions to the sessions array and flatten
      end
      (@afs << user_sessions).flatten!
    end
    @sec_grade_sessions = @sessions.select { |u| u[:grade_level] === '2' }
    @trd_grade_sessions = @sessions.select { |u| u[:grade_level] === '3' }
    @sessions.size
  end

  def avg_engagement
      @feedbacks = []
      @users_uniq.each do |u|
        user_feedbacks = Feedback.where(vol_id: u.id)
        unless user_feedbacks.empty?
          user_feedbacks.each do |fu|
            @feedbacks << fu
          end
        end
      end

    @feedbacks = @feedbacks.reject { |f| f[:mood].nil? }
    # check for no feedbacks
    if @feedbacks.nil? || @feedbacks.empty?
      engagement_average = 0
    else
      engagement_sum = @feedbacks.sum { |f| f[:mood] }
      engagement_average = engagement_sum / @feedbacks.size
    end
    engagement_average
  end

  def set_users
    # all districts, all schools, all tutors
    if params[:district_id].to_i.zero? && params[:school_id].to_i.zero?
      @users = User.all
    end

    # single district, all schools, all tutors
    if params[:district_id].to_i > 0 && params[:school_id].to_i.zero?
       @users = []
          @district = District.find(params[:district_id])
          @district.schools.each do |s|
           @school_users =  User.where("?=ANY(school_id)", s.id)
            @school_users.each do |u|
              @users << u
            end
          end
    end

    # single district, single school all tutors
     if params[:district_id].to_i > 0 && params[:school_id].to_i > 0
       @users = User.where("?=ANY(school_id)", params[:school_id].to_i)
     end

    # single district, single school, single tutor
      if params[:tutor_id].to_i > 0
        @users = User.where(id: params[:tutor_id])
      end

    # we didn't find any users
    if @users.nil?
      message = { message: 'We do not have any tutors for that school.' }
      render json: message, status: :unprocessable_entity
    end
  end

  # Only allow a trusted parameter "white list" through.
  def user_params
    params.permit(:school_id, :district_id, :tutor_id, :school_year)
  end
end